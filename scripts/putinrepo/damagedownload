#!/usr/bin/python
# -*- coding: utf-8 -*-

from __future__ import print_function
from __future__ import unicode_literals
from __future__ import absolute_import
from __future__ import division

from osgeo import gdal

import logging
import numpy as np
import os
import re
import shlex
import subprocess

SHEET = re.compile('^i(?P<unit>[0-9]{2}[a-z])[a-z][0-9]_[0-9]{2}$')


def get_tables_and_names():
    """ Get names from the database. """
    psql_command = 'psql raster --host 10.100.119.153 --username buildout'
    result = dict(data_ahn=[], data_lgn=[])

    # Build table as we loop results
    for table in result.keys():
        print('Getting list list for {}.'.format(table))
        with open('{}.txt'.format(table)) as textfile:
            for line in textfile:
                words = line.split()
                if words:
                    match = SHEET.match(words[0].strip())
                if match:
                    name, separator, nodatavalue = words
                    result[table].append(dict(name=name, nodatavalue=nodatavalue))

    return result


def get_gdal_argument(table, name):
    """ Return the argument for gdal.Open(). """
    template = ' '.join([
        "PG:host=10.100.119.153",
        "port=5432",
        "dbname='raster'",
        "user='buildout'",
        "password='buildout'",
        "schema='public'",
        "table='{table}'",
        "where='filename=\\'{name}\\''",
        "mode=1",
    ])
    return template.format(table=table, name=name)


def convert(table, name, nodatavalue):
    """ Store postgisraster as tiff, with nodatavalue. """
    # Check if it exists, try to create dir.
    tifpath = os.path.join(table,
                           SHEET.match(name).group('unit'),
                           name + '.tif')

    if os.path.exists(tifpath):
        print('Skipping {}: {}.'.format(table, name))
        return

    try:
        os.makedirs(os.path.dirname(tifpath))
    except OSError:
        pass  # That's ok.

    # Determine fillvalue and datatypes
    various = dict(data_lgn=(np.iinfo('u1').max, np.uint8, gdal.GDT_Byte),
                   data_ahn=(np.finfo('f4').min, np.float32, gdal.GDT_Float32))
    fill_value, numpy_type, gdal_type = various[table]

    # Read source data and set correct nodatavalue
    print('Downloading {}: {}.'.format(table, name))
    gdal_argument = get_gdal_argument(table=table, name=name)
    source = gdal.Open(gdal_argument)
    data = source.ReadAsArray()
    try:
        mask = np.equal(data, numpy_type(nodatavalue))
    except:
        mask = np.equal(data, np.float32(nodatavalue))
        print('Dataset was in float; found {} nodata pixels'.format(mask.sum()))
    projection = source.GetProjection()
    geotransform = source.GetGeoTransform()
    masked_array = np.ma.array(data,
                               mask=mask,
                               dtype=numpy_type,
                               fill_value=fill_value)

    # Write to tiff
    print('Converting {}: {}.'.format(table, name))
    driver = gdal.GetDriverByName(b'GTiff')
    try:
        target = driver.Create(str(tifpath),
                               data.shape[1],
                               data.shape[0],
                               1,
                               gdal_type,
                               ['COMPRESS=DEFLATE'])
        target.SetProjection(projection)
        target.SetGeoTransform(geotransform)
        band = target.GetRasterBand(1)
        band.SetNoDataValue(float(masked_array.fill_value))
        band.WriteArray(masked_array.filled())
        target = None
    except Exception as e:
        logging.exception('uh, oh.')
        target = None  # Close dataset
        try:
            os.remove(tifpath)
        except OSError:
            pass  # That's ok.
        raise e


def main():
    """
    Function to get the data
    Function to write the geotiff
    Function to get the correct path from the name
    Must also get the nodata value correctly!
    """
    tables = get_tables_and_names()
    remaining = {table: len(records) for table, records in tables.items()}
    for table, records in tables.items():
        for record in records:
            name = record['name']
            nodatavalue = record['nodatavalue']
            remaining_list = [p for q in remaining.items() for p in q]
            print('Remaining: {} {}, {} {}.'.format(*remaining_list))
            convert(table, name, nodatavalue)
            remaining[table] -= 1
    print('Done.')

if __name__ == '__main__':
    exit(main())
